# 02_初識SLAM
###### tags: `SLAM`
## 主要目標:
1. 了解一個視覺SLAM架構由哪幾個模組組成，各模組的工作是什麼
2. 架設程式環境，為開發和實驗做準備。
3. 了解如何在Linux下編譯並執行一個程式，如果程式出了問題，又該如何偵錯它。
4. 掌握cmake的基本使用方法。

- 概括地介紹一個視覺SLAM系統的結構，作為後續內容的大綱。
- 實作部分介紹環境架設、程式基礎，最後完成一個``'Hello slam'``
## 2.1 引子
- <機率機器人>: 雷射SLAM
- ROS: 雷射定位、雷射建圖
- 其他感測器:
    - 輪式編碼器
    - IMU
    - 二維碼
### 一元相機
- 藉由相機移動形成視差
- ==即使我們知道了物體遠近，它們仍然只是一個相對的值==(why...視覺里程計解釋7、8)
- 一元SLAM估計的軌跡和地圖將與真實的軌跡和地圖相差一個因數，也就是尺度
- 由於一元SLAM無法僅憑影像確定這個真實尺度，所以又稱為尺度不確定性
- 平移才能計算深度、以及尺度不確定性，這是一元SLAM的主要麻煩
### 二元相機和深度相機
#### 二元相機
- 二元相機由兩個一元相機組成，但兩個相機之間的距離(基準線)已知。
- 基準線距離越大，能夠測量到的物體就越遠
- 設定與標定均較為複雜
- 計算量是主要問題
#### 深度相機(RGB-D)
- 透過紅外結構光或Time-of-Flight(ToF)原理，測出物體與相機之間的距離。
- 常用的RGB-D相機包含Kinect/Kinect V2、Xtion Pro Live、RealSense
- 測量範圍窄、雜訊大、視野小、易受日光干擾、無法測量透射材質，主要用於室內
## 2.2 經典視覺SLAM架構
感應器資訊讀取→前端視覺里程計→後端(非線性)優化→建圖
       　　　　↘　　　　　　　　　　　　↗
         　　　　　→　　→　　→　　→　　→
　　　　　　　　　迴路檢測

整個SMAL流程包含以下步驟: 
- 感測器資訊讀取: 影像、碼盤、慣性感測器等
- 前端視覺里程計(Visual Odometry，VO): 估算相鄰影像間相機的運動、局部地圖的樣子
- 後端(非線性)最佳化(Optimization): 
- 迴路檢測(Loop Closure Detection): 如果檢測到迴路，把資訊提供給後端進行處理
- 建圖(Mapping)

==如果把工作環境限定在靜態、剛體、光源變化不明顯、沒有人為干擾的場景，那麼這種技術已經相當成熟。==
### 2.2.1 視覺里程計
- 相鄰影像間的相機運動
- 現在，假設我們已有一個視覺里程計，估計了兩張影像間的相機運動。
- 一方面，把相鄰時刻的運動串起來，就組成了機器人的運動軌跡，進一步解決了定位問題。
- 另一方面，根據每個時刻的相機位子，計算出各像素對應的空間點的位置，就獲得了地圖。
- 視覺里程計有飄移問題，且會累積飄移，因此需要後端最佳化和迴路檢測。
- 迴路檢測負責把回到原始位置檢測出來
- 後端最佳化根據此資訊，校正整個軌跡形狀
### 2.2.2 後端最佳化
- 如何從這些帶有雜訊的資料中估計整個系統的狀態
- 這個狀態估計的不確定性有多大- 最大後驗機率估計(Maximum-a-Posteriori，MAP)
- 主要是濾波與非線性最佳化演算法
- 狀態估計問題: 空間狀態不確定性的估計: 對運動主體本身和周圍環境空間不確定性的估計
- 狀態估計理論: 把定位和建圖的不確定性表達出來
- 採用濾波器或非線性最佳化，估計狀態的平均值和不確定性(方差)。
### 2.2.3 迴路檢測
- 主要解決估計隨時間飄移的問題。
- 識別到過的場景的能力
- 視覺迴路檢測實質上是一種計算圖像資料相似性的演算法。
### 2.2.4 建圖
- 拓樸地圖
- 二維地圖
- 3D地圖
- 帶紋理的三角面片
### 度量地圖
- 稀疏地圖進行了某種程度的抽象，舉例來說，選擇一部分具有代表意義的東西，稱之為路標(landmark)，那麼一張稀疏地圖就是由路標組成的地圖。
- 相對的，稠密地圖注重於建模所有看到的東西。定位時用稀疏路標地圖就足夠了。
- 而用於導航時，則常常需要稠密地圖
- 佔據、空間、未知三種狀態
### 拓樸地圖
- 拓樸地圖是一個graph，由節點和邊組成，只考慮節點間的聯通性
- 如何對地圖進行分割，形成節點和邊
- 又如何使用拓樸地圖進行導航與路徑規劃，仍是有待研究的問題。
# SLAM問題的數學表述
設時間為$t = 1, 2, ..., k$, 對應的位子$x_{1}, ..., x_{k}$，假設地圖由landmark構成，不一定會同時觀測到所有點，假設有N個點，記為$y_{1}, ... y_{k}$.
則: 

什麼是運動？檢查從$k-1$到$k$，$x$如何變化
什麼是觀測? 假設$k$時刻於$x_{k}$處探測到了某一個路標$y_{j}$，我們要檢查如何用數學語言來描述這件事情。

以$x_{k} = f(x_{k-1}, u_{k}, w_{k})$, where $u_{k}$是運動感測器的輸入，$w_{k}是雜訊$，來描述運動過程，稱為運動方程式。

$z_{k, j} = h(y_{j}, x_{k}, v_{k, j})$ where $v_{k, j}$是觀測雜訊，y是路標點，z為觀測資料，h為觀測方程式。

- 據此，SLAM問題建模成了一個狀態估計問題

## 2.4 實作
### 2.4.1 安裝Linux
### 2.4.2 Hello SLAM
### 2.4.3 使用cmake
- 新增一個CMakeList.txt
```
cmake_minimum_required( VERSION 2.8)
project ( HelloSlAM)
add_executable(helloSLAM helloSLAM.cpp)
```
接著使用cmake. 和 make
我做了什麼?
- 指定一個專案名稱
- 一個可執行程式

更一般的做法，創建一個build資料夾，```cmake ..```接著```make```
### 2.4.4使用函數庫
1. 撰寫只有void函式的cpp檔
2. 在CMakeList加入```add_library( 函數庫名稱 檔案名.cpp)
3. 將產生.a檔
4. 在add_library加入SHARED，就會產生.so檔(共用函數庫)
- 靜態程式庫每次呼叫都會產生一個備份，共用函數庫則只有一個備份
- 為函數庫撰寫標頭檔
- 在CMakeList.txt，增加一個可執行程式的產生指令，連結到函數庫``` target_link_libraries(可執行檔 函數庫)

### 2.4.5 使用IDE
1. 支援cmake專案
2. 有反白、跳躍、補全等功能，能自動排版
3. 方便地看到各個檔案和目錄樹
4. 一鍵編譯、中斷點偵錯

- 在CMakeList.txt加入```set(CMAKE_BUILD_TYPE Debug")```設定編譯模式
- 使用gdb
## 2.5習題

**<SLAM文獻>**
1. 閱讀文獻11和12，你能看懂其內容嗎?
2. 閱讀SLAM的整體說明文獻，例如4、13-16，這些文獻關於SLAM的看法與本書有何異同?

**<編譯相關>**

3. g++指令有哪些參數? 怎麼寫參數可以更改產生的程式檔案名稱
(-o )[done]
4. 使用build資料夾來編譯你的cmake專案
`` cmake .. && make``
5. 刻意在程式中增加一些語法錯誤，看看編譯會產生什麼樣的資訊。你能看懂g++的錯誤訊息嗎
6. 如果忘了把函數庫連結到可執行程式上，編譯會顯示出錯嗎? 回報什麼樣的錯？
``useHello.cpp:(.text+0x14): undefined reference to `printHello()'``
7. 閱讀<cmake實作>，了解cmake的其他語法。
8. 增強Hello SLAM小程式，把它做成一個小程式庫，安裝到本機硬碟中，然後，新增一個專案，使用find_package找這個函數庫並呼叫
9. 閱讀其他cmake教學材料，例如https://github.com/TheErk/CMake-tutorial

**<開發工具>**

10. 找到KDevelop的官方網站，看看它還有哪些特性。你都用上了嗎?
11. 如果在第一講學習了Vim，試試KDevelop的Vim編輯功能


